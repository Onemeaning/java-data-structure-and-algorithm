# 						数据结构预算法

## 几个经典的算法题

* #### 字符串匹配（KMP）

* #### 汉诺塔小游戏（分治算法）

* #### 八皇后问题（回溯算法）

* #### 马踏棋盘问题（DFS + 贪心算法）

* #### 约瑟夫（丢手帕）问题（单项循环列表）

* #### 五子棋程序（二维数组 稀疏数组）

* #### 修路问题（最小生成树普利姆算法）

* #### 最短路径算法（弗洛伊德算法）

=======================================================================================

## 1、稀疏数组

![image-20200228154420263](E:\java架构师学习之路\JAVA学习笔记\images\sparearray.png)



## 2、队列Queue的相关问题

~~~ java
1) 两个指针: front (栈前指针) rear (栈尾指针)
2) 数组模拟栈注意数组的循环使用(取模运算)
3) rear == front判断栈是否为空?
4) ( rear + maxSize - front )% maxSize得到栈中数据的个数
~~~

### 3、单向列表

### 4、双向列表

### 5、单向循环列表（丢手帕问题）

**Josephu问题为:**设编号为1, 2, .n的n个人围坐一圈， 约定编号为k (1<=k<=n) 的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生-一个出队编号的序列。n=5,即有5个人；k=1,从第一一个人开始报数；m=2,数2下；

答案：2->4->1->5->3

### 6、栈

* **求解表达式的值**
* **逆波兰表达式**

```text
例如: (3+4)X5-6对应的后缀表达式就是34+5 x 6-,针对后缀表达式求值步骤如下:
队左至右扫描，将3和4压入堆栈;
遇到+运算符，因此弹出4和3 (4为根顶元素，3为次顶元素)，计算出3+4的值，得7，再将7入栈;
将5入栈:
接下来是X运算符，因此弹出5和7.计算出7X5=35.将35入栈:
将6入栈:
最后是-运算符，计算出35-6的值。即29.由此得出最终结果
```

* **中缀表达式转换为后缀表达式**（面试重点）

```text
具体步骤如下:
1、初始化两个栈:运算符栈s1和储存中间结果的栈s2;
2、从左至右扫描中缀表达式;
3、遇到操作数时，将其压s2;
4、遇到运算符时，比较其与s1栈项运算符的优先级:
  4-1）如果sl为空，或栈项运算符为左括号“(" ，则直接将此运算符入栈; 
  4-2）否则，若优先级比栈顶运算符的高，也将运算符压入sl;
  4-3）否则，将s1 栈项的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较;
5、遇到括号时:
  5-1)如果是左括号“("，则直接压入s1
  5-2)如果是右括号“)”。则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6、重复步骤2至5.直到表达式的最右边
7、将s1中剩余的运算符依次弹出并压入s2
8、依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式
```

### 6、递归（Recursion）

![image-20200305114503944](E:\java架构师学习之路\JAVA学习笔记\images\recursion.png)

#### **6.1对迷宫问题的讨论**

~~~
1)小球得到的路径，和程序员设置的找路策略有关即:找路的上下左右的顺序相关
2)再得到小球路径时， 可以先使用(下右上左)， 再改成(上右下左), 看看路径是不是有变化
3)测试回溯现象
4)思考: 如何求出最短路径?思路-》 代码实现.
~~~



#### 6.2八皇后问题介绍

~~~
八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯.贝瑟尔于
1848年提出:在8X8格的国际象棋上摆放八个皇后，使其不能互相攻击，即:任意两个皇后都不能处于同-行、
同- -列或同- -斜线上，间有多少种摆法(92)。
~~~



**八皇后问题算法思路分析**

~~~
1)第一个皇后先放第一行第一列
2)第二个皇后放在第二行第一列、然后判断是否0K，如果不OK， 继续放在第二列、第三列、依次把所有列都放完，找到一个合适。
3)继续第三个皇后，还是第一列、第二....直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
4) 当得到一个正确解时，在栈回退到上-一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.
5)然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤。
~~~







## 7、排序算法

### 7.1冒泡排序的及其优化版本 O(n^2)

**冒泡排序(Bubble Sorting) 的基本思想是:**

~~~
   通过对待排序序列从前向后(从下标较小的元素开始) ,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

   因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。
~~~



### 7.2选择排序 O(n^2)

**选择排序思想:**

~~~
   选择排序(select sorting)也是一种简单的排序方法。它的基本思想是:第一从arr[0]^ arr[n-1]中选取最小值，与arr[0]交换， 第二决从arr[1] arr[n-1]中选取最小值，与arr[1]交换， 第三次从arr[2] arr[n-1]中选取最小值，与arr[2]交换， ..第i次从arr[i-1]^ arr[n-1]中选取最小值，与arr[i-1]交换，..第n-1次从arr[n-2]^ arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。
~~~

### 7.3插入排序 O(n^2)

**插入排序法思想:**

~~~
  插入排序(Insertion Sorting)的基本思想是:把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。
~~~



### 7.4希尔排序 O(n log^2 n)

**希尔排序法介绍**

~~~
   希尔排序是希尔(DonaldShell)于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。
~~~

**希尔排序法基本思想**

~~~
   希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序:随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。
~~~

### 7.5快速排序 O(n^2)

**快速排序法介绍:**

~~~
   快速排序(Quicksort) 是对冒泡排序的一种改进。基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
~~~

### 7.6归并排序 O(n log n)

**归并排序介绍:**

~~~
   归并排序(MERGE- SORT)是利用归并的思想实现的排序方法，该算法采用经典的分治(divide- and-conquer)策略(分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案修补"在一
起，即分而治之)。

~~~

### 7.7基数排序 O(n * k)

**基数排序(桶排序)介绍:**

~~~
1)基数排序(radixsort)属于“分配式排序”(distributionsort) ，又称“桶子法”(bucket sort)或binsort, 顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
2)基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
3)基数排序(RadixSort)是桶排序的扩展
4)基数排序是1887年赫尔曼何乐礼发明的。它是这样实现的:将整数按位数切割成不同的数字，然后按每个位数分别比较。
~~~

![image-20200320110211298](E:\java架构师学习之路\JAVA学习笔记\images\radixSort.png)



## 8、查找算法

### 8.1 线性查找

### 8.2 二分查找

**二分查找的思路分析**

~~~
1.首先确定该数组的中间的下标 mid= (left+right)/2
2.然后让需要查找的数findVal和arr[mid]比较
2.1 findVal > ar[mid],说明你要查找的数在mid的右边,因此需要递归的向右查找
2.2 findVal < ar[(mid],说明你要查找的数在mid的左边，因此需要递归的向左查找
2.3 findVal == arr[mid]说明找到，就返回
//什么时候我们需要结束递归
1)找到就结束递归
2)递归完整个数组，仍然没有找到indVal ,也需要结束递归当left> right就需要退出

~~~

### 8.3 插值查找

​    适用于等差数列的情况，核心是改变了二分查找中的求 mid= (left+right)/2 的算法；

​    是一种自适应mid的算法；

~~~
//求出mid
int mid = left + (right - 1eft) * (findVal - arr[left]) / (arr[right] - arr[1eft]);
~~~



### 8.4 斐波那契查找 (黄金分割查找)

**斐波那契(黄金分割法)查找基本介绍:**

~~~
1)黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为虫外比。这是一个神奇的数字，会带来意向不大
的效果。
2)斐波那契数列{1.1.2,3,5,8, 13,21, 34, 55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618
~~~

![image-20200320194907562](E:\java架构师学习之路\JAVA学习笔记\images\fibnacciSearch.png)

 

## 9、树

#### **9.1.1为什么需要树这种数据结构**

~~~
1)数组存储方式的分析
优点:通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
缺点:如果要检索具体某个值，或者插入值(按- -定顺序)会整体移动， 效率较低。

2)链式存储方式的分析
优点:在一定程度上对数组存储方式有优化(比如:插入-个数值节点,只需要将插入节点，链接到链表中即可，删
除效率也很好)。
缺点:在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)

3)树存储方式的分析
能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree),既可以保证数据的检索速度，同时也可以
保证数据的插入，删除，修改的速度。
案例:[7,3,10,1,5,9,12] 
~~~

#### 9.1.2前中后序遍历

~~~
前序遍历:先输出父节点，再遍历左子树和右子树
中序遍历:先遍历左子树，再输出父节点，再遍历右子树
后序遍历:先遍历左子树，再遍历右子树，最后输出父节点
小结:看输出父节点的顺序，就确定是前序，中序还是后序
~~~

#### 9.1.3前中后序遍历查找

~~~
前序查找思路
1.先判断当前结点的no是否等于要查找的
2.如果是相等，则返回当前结点
3.如果不等，则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找
4.如果左递归前序查找，找到结点，则返回，否继续判断，当前的结点的右子节点是否
为空，如果不空，则继续向右递归前序查找.

中序查找思路
1.判断当前结点的左子节点是否为空，如果不为空，则遵归中序查找
2.如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点，否
则继续进行右递归的中序查找
3.如果右递归中序查找,找到就返回，否则返回null

后序查找思路
1.判断当前结点的左子节点是否为空，如果不为空，则递归后序查找
2.如果找到，就返回，如果没有找到，敦判断当前结点的右子节点是否为空，如果不为
空，则右递归进行后序查找，如果找到，就返回
3.就和当前结点进行，比如，如果是则返回，否则返回null
~~~

#### 9.1.4删除结点

~~~
规定:
1)如果删除的节点是叶子节点，则删除该节点
2)如果删除的节点是非叶子节点，则删除该子树
思路
1.因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删
除结点，而不能去判断当前这个结点是不是需要删除结点
2.如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将
this.left=null; 并且就返回(结束递归删除)
3.如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将
this.right=null;并 且就返回(结束递归删除)
4.如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
5.如果第4步也没有删除结点，则应当向右子树进行递归删除.
6.考虑如果树是空树root,如果只有一个root结点，则等价将二叉树置空

~~~



#### 9.2顺序存储二叉树

~~~
顺序存储二叉树的特点: 
1)顺序二叉树通常只考虑完全二叉树
2)第g个元素的左子节点为2*n+1
3)第h个元素的右子节点为2*n+2
4)第n个元素的父节点为(n-1)/ 2
5) n:表示二叉树中的第几个元素(按0开始编号如图所示)
~~~



#### 9.3 线索化二叉树

* **先看一个问题**

  将数列{1,3,6,8,10,14 } 构建成-颗二叉树，n+1=7；

  ![image-20200410214932381](E:\java架构师学习之路\JAVA学习笔记\images\plotBinaryTree.png)

  问题分析:
  1) 当我们对上面的二叉树进行中序遍历时，数列为{8,3, 10,1,6, 14}
  2)但是6,8,10,14这几个节点的左右指针，并没有完全的利用上.
  3)如果我们希望充分的利用各个节点的左右指针，让各个节 点可以指向自己的前后节点怎么办?
  4)解决方案-线索二叉树



* **线索二叉树基本介绍**
  1) n个结点的二叉链表中含有n+1 [ 公式2n-(n-1)=n+1]个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针(这种附加的指针称为"线索")
  2)这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
  3)一个结点的前一个结点，称为前驱结点
  4) - -个结点的后- -个结点，称为后继结点

  

* **思路分析**

![image-20200410215236153](E:\java架构师学习之路\JAVA学习笔记\images\threadedBinaryTree.png)

**说明:当线索化二叉树后，Node节点的属性left 和right ，有如下情况:**
1) left 指向的是左子树，也可能是指向的前驱节点.比如①节点left 指向的左子树，而0节点的left 指向的
就是前驱节点.
2) right 指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而回节点的right指向
的是后继节点.
I

* **遍历线索化二叉树**
  **说明:**对前面的中序线索化的二叉树，进行遍历
  **分析:**因为线索化后，**各个结点指向有变化，因此原来的遍历方式不能使用**，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。遍历的次序应当和中序遍历保持一致。



#### 9.4堆排序

**堆排序的基本思想是:**

1)将待排序序列构造成一个大顶堆
2)此时，整个序列的最大值就是堆顶的根节点。
3)将其与末尾元素进行交换，此时末尾就为最大值。
4)然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如.此反复执行，便能得到-一个有序序列了。
可以看到在构建大项堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.

#### 9.5 二叉排序树（BST）

**二叉排序树介绍：**
二叉排序树: BST: (Binary Sort(Search) Tree),对于二叉排序树的任何一-个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。
特别说明:如果有相同的值，可以将该节点放在左子节点或右子节点，比如针对前面的数据(7,3, 10,12,5,1,9)，对应的二叉排序树为:![image-20200427111814240](E:\java架构师学习之路\JAVA学习笔记\images\bst.png)

**二叉排序树的删除**
二叉排字树的删除情况比较复杂，有下面三种情况需要考虑
删除叶子节点(比如: 2,5,9,12)
删除只有一颗子树的节点(比如: 1)
删除有两颗子树的节点.(比如: 7,3, 10)

**思路分析**

~~~
第一种情况:
删除叶子节点(比如: 2, 5, 9, 12)
思路
(1)需求先去找到要删除的结点targetNode
(2)找到targetNode的父结点parent
(3)确定targetNode是parent的左子结点还是右子结点
(4)根据前面的情沉来对应删除
左子结点parent.left = null
右子结点parent.right = null;

第二种情况:删除只有一颗子树的节点比如1
思路
(1)需求先去找到要删除的结，点targetNode
(2)找到targetNode的父结点parent
(3)确定targetNode的子结点是左子结点还是右子结点
(4) targetNode是parent的左子结点还是右子结点

(5)如果targetNode有左子结点
5.1 如果targetNode是parent的左子结点
parent.left = targetNode.left;
5.2 如果targetNode是parent的右子结点
parent.right = targetNode.left;

(6)如果targetNode有右子结点
6.1如果targetNode是parent 的左子结点
parent.left = targetNode.right;
6.2如果targetNode是parent的右子结点
parent.right = targetNode.right

情况三:删除有两颗子树的节点. (比如: 7,3，10)
思路
(1)需求先去找到要删除的结点targetNode
(2)找到targetNode的父结点parent
(3)从targetNode 的右子树找到最小的结点 \ 或者从targetNode的左子树找到最大的节点
(4)用一个临时变量，将最小结点的值保存temp = 11
(5)删除该最小结点
(6) targetNode.value = temp
~~~

#### 9.6平衡二叉树（AVL）

**BST不足之处：**

![]()

**基本介绍**

~~~
1)平衡二叉树也叫平衡二叉搜索树(Self-balancing binarysearch tree)又被称为AVL树，可 以保证查询效率较高。
2)具有以下特点:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1,并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、 伸展树等。
~~~

**左旋**

~~~
当前节点的右子树的高度与左子树高度之差大于1时候，（右子树高度大，进行左旋转）；
~~~

![image-20200528201210855](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\左旋转.png)

**右旋**

![image-20200528201356631](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\右旋转.png)

**双旋转**

![image-20200528201538644](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\双旋转.png)

#### 9.6多路查找树

##### **1、二叉树的问题所在**

~~~
（1）二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)，就存在如下问题:
（2）问题1:在构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响
（3）问题2:节点海量，也会造成二叉树的高度很大，会降低操作速度.

~~~

##### 2、**多叉树**

~~~
在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点就是多叉树(multiway tree)
后面我们讲解的2-3树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。
举例说明(下面2-3树就是-颖多叉树)
~~~

![image-20200529201509007](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\2-3树.png)

##### 3、**B树的基本介绍**

~~~
（1）如图B树通过重新组织节点，降低了 树的高度.
（2）文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一一个页(页得大小通常为4k),这样每个节点只需要一次I/O就可以完全载入
（3）将树的度M设置为1024,在600亿个元素中最多只需要4次IO操作就可以读取到想要的元素，B树(B+)广泛应用于文件存储系统以及数据库系统中
~~~

##### **4、2-3树的基本概念**

~~~
2-3树是最简单的B树结构,具有如下特点:
1) 2-3树的所有叶子节点都在同一 层.(只要是B树都满足这个条件)
2)有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
3)有三个子节点的节点叫三节点，节要么没有子节点，要么有三个子节点.
4)2-3树是由二节点和三节点构成的树。
~~~

**插入规则**

~~~
1) 2-3树的所有叶子节点都在同- -层.(只要是B树都满足这个条件)
2)有两个子节点的节点叫二节点， 二节点要么没有子节点，要么有两个子节点
3)有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4)当按照规则插入一个数到某个节点时， 不能满足上面三个要求，就需要拆,先向上拆，如果上层满，则拆本层，
拆后仍然需要满足.上面3个条件。
5)对于三节点的子树的值大小仍然遵守(BST二叉排序树)的规则

~~~

##### 5、B树、B+树、B*树的概念

	B-tree树即B树，B即Balanced,平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree 就是指的B树。
**B树的介绍**
前面已经介绍了2-3树和2-3-4树，他们就是B树(英语: B-tree 也写成B-树)，这里我们再做-一个说明，我们在学
习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图: .

![image-20200529202316577](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\B树.png)

**B树的说明:** 

~~~
1) B树的阶: 节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4
2) B-树的搜索，从根结点开始，对结点内的关键字(有序)序列进行二分查找，如果命中则结束，否则进入查询关键字所属范
   围的儿子结点:重复，直到所对应的儿子指针为空，或已经是叶子结点
3) 关键字集合分布在整颗树中， 即叶子节点和非叶子节点都存放数据.
4) 搜索有可能在非叶子结点结束
5) 其搜索性能等价于在关键字全集内做一次分查找
~~~

**B+树介绍：**

![image-20200529202546324](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\B+树.png)

**B+树的说明:** 

~~~
1) B+树的搜索 与B树也基本相同，区别是B+树只有达到叶子结点才命中( B树可以在非叶子结点命中)，其性能也等价于在    关键字全集做一次二分查找
2)所有关键字都出现在叶子结点的链表中(即数据只能在叶子节点[也叫稠密索引] )，且链表中的关键字(数据)恰好是有序   的。
3)不可能在非叶子结点命中
4)非叶子结点相当于是叶子结点的索引 (稀疏索引)叶子结点相当于是存储(关键字)数据的数据层
5)更适合文件索引系统
6) B树和B+树各有 自己的应用场景，不能说B+树完全比B树好，反之亦然.

~~~

 B\*树的介绍

~~~
B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。
~~~

![image-20200529202841093](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\Bsatr树.png)

~~~
1) B*树定义了非叶子结点关键字个数至少为(2/3)*M， 即块的最低使用率为2/3， 而B+树的块的最低使用率为的1/2。
2)从第1个特点我们可以看出，B*树分配新缍点的概率比B+树要低，空间使用率更高
~~~

### 10、图

#### 10.1图的基本介绍

**为什么要有图**

~~~
1)前面我们学了线性表和树
2)线性表 局限于一个直接前驱和一个直接后继的关系
3)树也只能有一一个直接前驱也就是父节点
4)当我们需要表示多对多的关系时， 这 里我们就用到了图
~~~


**图的举例**

![image-20200529204045678](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\图.png)



**图的概念**

![image-20200529204255660](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\图的概念.png)

**图的表示：**

![image-20200529204418371](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\邻接矩阵.png)

![image-20200529204518224](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\images\邻接表.png)



#### 10.2图的创建

![image-20200601174352127](C:\Users\Meanlam\OneDrive\java架构师学习之路\JAVA学习笔记\图的创建.png)

#### 10.3图的遍历

**图的遍历的介绍**

~~~
所谓图的遍历，即是对结点的访问。-一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历(2)广度优先遍历。
~~~

##### 10.3.1 深度优先遍历（Depth First Search）

**基本思想**

~~~
1)深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一一个邻接结点，可以这样理解:每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。
2)我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。
3) 显然，深度优先搜索是一个递归的过程
~~~

**基本步骤**

~~~
1)访问初始结点v，并标记结点v为已访问。
2)查找结 点v的第- -个邻接结点w。
3)若w存在， 则继续执行4，如果w不存在，则回到第1步，将从v的下一-个结点继续。
4)若w未 被访问，对w进行深度优先遍历递归(即把w当做另-一个v，然后进行步骤123)。
5)查找结点v的w邻接结点的下一一个邻接结点，转到步骤3。
~~~

**核心代码实现**

~~~java
 /************************深度优先搜索Start****************************************/

    /**
     * 查找一个顶点的第一个相邻的节点。
     * @param i 待查找第一个相邻节点的下标
     * @return -1 表示没有找到，否则返回数组的下标。
     */
    private int getFirstNeighbor(int i){
        for (int j = 0; j < getVertexs(); j++) {
            if (edges[i][j] > 0)
                return j;
        }
        return -1;
    }

    /**
     * 根据前一个相邻的顶点的下标，来获取下一个相邻的顶点。
     * @param v1 前一个相邻顶点的下标，下一个相邻顶点的下标。
     * @param v2
     * @return
     */
    private int getNextNeighbor(int v1, int v2){
        for (int j = v2+1; j < getVertexs(); j++) {
            if (edges[v1][j] > 0){
                return j;
            }
        }
        return -1;
    }

    /**
     * 对一个节点的深度优先搜索
     * @param start 搜索的起始位置的下标
     */
    private void dfs(boolean[] isVisited ,int start){
        System.out.print(getValueByIndex(start) + "-->");
        //获取第一个相邻顶点的下标值：
        int w = getFirstNeighbor(start);
        isVisited[start] = true;

        //有相邻的顶点；
        while (w != -1){
           if (!isVisited[w]){
               //没有被访问，则会以当前的节点作为起始顶点递归访问
               dfs(isVisited,w);
           }
           //如果w顶点已经被访问了
           w = getNextNeighbor(start, w);

        }
    }

    /**
     * 深度优先搜索
     */
    public void dfs(){
        for (int i = 0; i < getVertexs(); i++) {
            if (!isVisited[i])
                dfs(isVisited,i);
        }

    }

    /*************************************深度优先搜索END********************/
~~~

##### 10.3.2 广度优先遍历(Broad First Search)

**基本思想**

~~~
类似于一个分层搜索的过程，广度优先遍历需要使用-一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点.
~~~

**算法步骤**

~~~
1) 访问初始结点并标记结点为已访问。
2)结点v入队列
3)当队列非空时， 继续执行，否则算法结束。
4)出队列，取得队头结点u. 
5)查找结 点u的第- -个邻接结 点w。
6) 若结点u的邻接结点w不存在，则转到步骤3;否则循环执行以下三个步骤:
	6.1若结点w尚未被访问，则访问结点w并标记为己访问。
	6.2结点w入队列
	6.3查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。
~~~

**核心代码**

~~~java
 /*************************************广度优先搜索START************************/

    /**
     * 对一个节点的广度优先搜索
     * @param isVisited 顶点访问情况分析
     * @param start 节点索引
     */
    private void bfs(boolean[] isVisited, int start){
        int u; //队列头结点的下标；
        int w; //邻接节点
        LinkedList<Integer> queue = new LinkedList<>();//充当队列，记录节点访问的顺序
        System.out.print(getValueByIndex(start) + "-->");
        isVisited[start] = true;
        queue.addLast(start);
        
        while (!queue.isEmpty()){
            u = queue.removeFirst();
            w = getFirstNeighbor(u);
            while (w != -1){
                if (!isVisited[w]){
                    System.out.print(getValueByIndex(w) + "-->");
                    isVisited[w] = true;
                    queue.addLast(w);
                }
                w = getNextNeighbor(u,w);
            }

        }
    }

    /**
     * 广度优先搜索
     */
    public void bfs(){
        for (int i = 0; i < getVertexs(); i++) {
            if (!isVisited[i])
                bfs(isVisited, i);
        }
    }
 /*************************************广度优先搜索END************************/
~~~

